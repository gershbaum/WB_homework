func tryTest() func() {
	fmt.Println("tryTest")
	return func() {
		fmt.Println("tryTest2")
	}
}

func main() {
	defer fmt.Println("Первое время:", time.Now())
	defer tryTest()
	time.Sleep(2 * time.Second)
	defer fmt.Println("Второе время", time.Now())
}

1. При `defer tryTest()()`:

tryTest
Второе время 2024-12-19 01:28:54.2741684 +0300 MSK m=+2.001787001
tryTest2
Первое время: 2024-12-19 01:28:52.2729414 +0300 MSK m=+0.000560001


2. При `defer tryTest()`:

Второе время 2024-12-19 01:29:31.0197113 +0300 MSK m=+2.001015201
tryTest
Первое время: 2024-12-19 01:29:29.0186961 +0300 MSK m=+0.000000001

__________________________________________________________________

Как было показано на лекции, в момент вызова `defer` аргументы функции вычисляются сразу, одна сама функция откладывается и будет 
выполнена лишь тогда, когда завершится функция, в которой был вызван `defer`. Также изестно, что `defer` выполняется в обратном 
порядке.

1. Рассмотрим строку `defer tryTest()()`.

`tryTest()()` состоит из двух вызовов функций подряд. Первый вызов: `tryTest()` - внешний. Печатается "tryTest" и возвращается 
функция func() {fmt.Println("tryTest2")}. Второй вызов: `()`. После того, как `tryTest()` вернула функцию, эта возвращенная функция
сразу же вызывается при втором `()`: `tryTest()()`. Поэтому выполняется `fmt.Println("tryTest2")` и печатается "tryTest2". То есть, 
в `tryTest()()` сначала вызывается `tryTest()`, а следом `()` - функция, которую вернула `tryTest()`. 
После того, как оба вызова выполнились, по идее `defer` должен отложиться, но откладывать уже нечего, оба вызова выполнены. Поэтому 
в данном случае он ничего не делает. `tryTest()()` выполняется сразу, поскольку `tryTest()` вызывается немедленно и на момент 
завершения функции `main` в стеке `defer` ничего не остается.

2. Теперь рассмотрим строку `defer tryTest()`.

В данном случае выполение откладывается до конца функции. Вызов `tryTest()` не выполняется сразу. Go добавляет этот вызов в стек 
отложенных функций и, соответственно, сама функция `tryTest()` будет выполнена позже, когда завершится выполнение main, в которой 
и был вызван `defer`. Важно, что в данном случае не вызывается функция, не выполняются аргументы, а только лишь откладывается 
выполнение функции. Вывода на консоль не происходит. Когда main завершает свое выполнение, начинают выполняться и все отложенные 
функции (в обратном порядке), объявленные с помощью `defer`. Таким образом, "tryTest" выводится только при выходе из функции main.


Резюме: при `defer tryTest()()` функция `tryTest()`и ее возвращаемая функция выполяются сразу, до того, как `defer` "зарегистрировал" 
свой отложенный вызов, поскольку он откладывает выполнение только самого выражения. При `defer tryTest()` вызов `tryTest()` 
откладывается и выполняется в конце функции main.

