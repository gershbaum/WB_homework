package main

import (
	"fmt"
)

func main() {
	var numbers []*int
	for _, value := range []int{10, 20, 30, 40} {
		numbers = append(numbers, &value)
	}

	for _, number := range numbers {
		fmt.Printf("%d ", *number)
	}
}

________________________________________________________________________________________________________________________________________________________________

Мы создаем пустой слайс `numbers`, который предназначен для хранения указателей на значения типа `int`. 

Первый цикл: `range` проходит по каждому элементу слайса и на каждой из итераций в `value` хранится текущее значение из слайса. В слайс `numbers` добавляется
адрес переменной `value` (`&value`).

Второй цикл: `range` проходит по каждому указателю в `numbers`. Выводится значение по адресу, хранящемуся в  `number` (`*number`).

Вывод с версией Go 1.20: 40 40 40 40
Вывод с версией Go 1.23: 10 20 30 40

Go 1.20: переменная `value` создается один раз до начала цикла и используется на каждой итерации. Вместо того, чтобы создавать новую переменную на каждом шаге
цикла, программа переиспользует одну и ту же область памяти для хранения значений. Соответственно, на каждой итерации новое значение записывается в ту же 
область памяти, и предыдущие данные в этой области заменяются. В итоге, слайс `numbers` содержит 4 одинаковых адреса и при печати выводится последнее значение
`value`: 40 40 40 40.

G0 1.23: начиная с этой версии (создатели устранили источник багов) при использовании `range` используемая переменная создается на каждой итерации (в нашем 
случае - `value`), а не переиспользуется. То есть, на каждом шаге цикла `for` в слайс `numbers` будет добавляться адрес новой переменной, и каждый из адресов 
будет ссылаться на уникальную переменную. В итоге, слайс `numbers` содержит 4 уникальных адреса, каждый из которых указывает на свое значение. При печати 
тогда будет выводиться: 10 20 30 40.

p.s. при работе с версией Go 1.20 при использовании цикла `range` для корректной работы как вариант можно вручную создать новую переменную внутри цикла, тогда
`value` будет новой на каждой итерации, что поможет избежать переиспользования:

for _, value := range []int{10, 20, 30, 40} {
    valueNew := value
	numbers = append(numbers, &valueNew)
}
