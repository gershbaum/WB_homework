# WBTECH homework. SQL.

## ДЗ 1. Sorting and grouping.

### Часть 1
Набор данных для выполнения заданий:

users.csv  
products.csv

Для каждого города выведите число покупателей из соответствующей таблицы, сгруппированных по возрастным категориям и отсортированных по убыванию количества покупателей в каждой категории.

*Примечание:* под возрастной категорией подразумевается возраст человека в полных годах (например, 21, 35, 65 и т.д.). Можете дополнительно написать запрос именно для “категорий”: от 0 до 20 (категория young), от 21 до 49 (категория adult), от 50 и выше (категория old)

Рассчитайте среднюю цену категорий товаров в таблице `products`, в названиях товаров которых присутствуют слова «hair» или «home». Среднюю цену округлите до двух знаков после запятой. Столбец с полученным значением назовите `avg_price`.

Поля в результирующей таблице: `avg_price`, `category`.

### Часть 2
Набор данных о продавцах для выполнения следующих заданий:

sellers.csv

*Не использовать JOIN для выполнения заданий!*

1. Назовем “успешными” (’rich’) селлерами тех:

   - кто продает более одной категории товаров
   - и чья суммарная выручка превышает 50 000

Остальные селлеры (продают более одной категории, но чья суммарная выручка менее 50 000) будут обозначаться как ‘poor’. Выведите для каждого продавца количество категорий, средний рейтинг его категорий, суммарную выручку, а также метку ‘poor’ или ‘rich’.

Назовите поля: `seller_id`, `total_categ`, `avg_rating`, `total_revenue`, `seller_type`. Выведите ответ по возрастанию id селлера.

*Примечание:* Категория “Bedding” не должна учитываться в расчетах.

2. Для каждого из неуспешных продавцов (из предыдущего задания) посчитайте, сколько полных месяцев прошло с даты регистрации продавца.  
Отсчитывайте от того времени, когда вы выполняете задание. Считайте, что в месяце 30 дней. Например, для 61 дня полных месяцев будет 2.  
Также выведите разницу между максимальным и минимальным сроком доставки среди неуспешных продавцов. Это число должно быть одинаковым для всех неуспешных продавцов.

Назовите поля: `seller_id`, `month_from_registration`, `max_delivery_difference`. Выведите ответ по возрастанию id селлера.

*Примечание:* Категория “Bedding” по-прежнему не должна учитываться в расчетах.

3. Отберите продавцов, зарегистрированных в 2022 году и продающих ровно 2 категории товаров с суммарной выручкой, превышающей 75 000.

Выведите `seller_id` данных продавцов, а также столбец `category_pair` с наименованиями категорий, которые продают данные селлеры.  
Например, если селлер продает товары категорий “Game”, “Fitness”, то для него необходимо вывести пару категорий `category_pair` с разделителем “-” в алфавитном порядке (т.е. “Game - Fitness”).

Поля в результирующей таблице: `seller_id`, `category_pair`.

## ДЗ 2. Join.

### Часть 1

1. Найти клиента с самым долгим временем ожидания между заказом и доставкой. Для этой задачи есть таблицы "Customers", "Orders".

2. Найти клиентов, сделавших наибольшее количество заказов, и для каждого из них найти среднее время между заказом и доставкой, а также общую сумму всех их заказов. Вывести клиентов в порядке убывания общей суммы заказов.

3. Найти клиентов, у которых были заказы, доставленные с задержкой более чем на 5 дней, и клиентов, у которых были заказы, которые были отменены. Для каждого клиента вывести имя, количество доставок с задержкой, количество отмененных заказов и их общую сумму. Результат отсортировать по общей сумме заказов в убывающем порядке.

### Часть 2

*Примечание:* использовать в этой задаче подзапросы

У нас есть две таблицы:

Orders содержит следующие поля:

   - `order_id` (идентификатор заказа)
   - `order_date` (дата заказа)
   - `product_id` (идентификатор продукта)
   - `order_amount` (сумма заказа)

Products содержит следующие поля:

   - `product_id` (идентификатор продукта)
   - `product_name` (наименование продукта)
   - `product_category` (категория продукта)

**Задача:** написать SQL-запрос, который выполнит следующие задачи:

1. Вычислит общую сумму продаж для каждой категории продуктов.  
2. Определит категорию продукта с наибольшей общей суммой продаж.  
3. Для каждой категории продуктов, определит продукт с максимальной суммой продаж в этой категории.

## ДЗ 3. Window functions.

### Часть 1

Вам предоставлена таблица с зарплатами сотрудников разных отделов (industry):

Salary.csv

Выведите список сотрудников с именами сотрудников, получающими самую высокую зарплату в отделе. Столбцы в результирующей таблице: `first_name`, `last_name`, `salary`, `industry`, `name_ighest_sal`. Последний столбец - имя сотрудника для данного отдела с самой высокой зарплатой.

Выведите аналогичный список, но теперь укажите сотрудников с минимальной зарплатой.

В каждом случае реализуйте расчет двумя способами: с использованием функций min max (без оконных функций) и с использованием `first/last value`.

### Часть 2

Данные для выполнения последующих заданий:

GOODS.xslx  
SALES.xslx  
SHOPS.xslx

1. Отберите данные по продажам за 2.01.2016. Укажите для каждого магазина его адрес, сумму проданных товаров в штуках, сумму проданных товаров в рублях. Столбцы в результирующей таблице:

`SHOPNUMBER`, `CITY`, `ADDRESS`, `SUM_QTY SUM_QTY_PRICE`.

2. Отберите за каждую дату долю от суммарных продаж (в рублях на дату). Расчеты проводите только по товарам направления ЧИСТОТА. Столбцы в результирующей таблице:

`DATE_`, `CITY`, `SUM_SALES_REL`.

3. Выведите информацию о топ-3 товарах по продажам в штуках в каждом магазине в каждую дату. Столбцы в результирующей таблице:

`DATE_`, `SHOPNUMBER`, `ID_GOOD`.

4. Выведите для каждого магазина и товарного направления сумму продаж в рублях за предыдущую дату. Только для магазинов Санкт-Петербурга. Столбцы в результирующей таблице:

`DATE_`, `SHOPNUMBER`, `CATEGORY`, `PREV_SALES`.

### Часть 3

Создайте таблицу query (количество строк - порядка 20) с данными о поисковых запросах на маркетплейсе.

Поля в таблице: `searchid`, `year`, `month`, `day`, `userid`, `ts`, `devicetype`, `deviceid`, `query`. ts - время запроса в формате unix.

*Рекомендация по наполнению столбца query:* Заносите последовательные поисковые запросы. Например, `к`, `ку`, `куп`, `купить`, `купить кур`, `купить куртку`.

Для каждого запроса определим значение `is_final`:

   - если пользователь вбил запрос (с определенного устройства), и после данного запроса больше ничего не искал, то значение равно 1
   - если пользователь вбил запрос (с определенного устройства), и до следующего запроса прошло более 3х минут, то значение также равно 1
   - если пользователь вбил запрос (с определенного устройства), И следующий запрос был короче, И до следующего запроса прошло прошло более минуты, то значение равно 2
   - иначе - значение равно 0

Выведите данные о запросах в определенный день (выберите сами), у которых `is_final` пользователей устройства android равен 1 или 2.

Столбцы в результирующей таблице:

 `year`, `month`, `day`, `userid`, `ts` , `devicetype`, `deviceid` , `query`, `next_query`, `is_final`.
