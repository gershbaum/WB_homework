/*
 * Для каждого запроса определим значение is_final:
 * 
 * 	  а) если пользователь вбил запрос (с определенного устройства), 
 * и после данного запроса больше ничего не искал, то значение равно 1
 * 
 * 	  б) если пользователь вбил запрос (с определенного устройства), 
 * и до следующего запроса прошло более 3х минут, то значение также равно 1
 * 
 * 	  в) если пользователь вбил запрос (с определенного устройства), 
 * и следующий запрос был короче, и до следующего запроса прошло прошло более минуты, то значение равно 2
 * 
 * 	  г) иначе - значение равно 0
 */

-- Создадим таблицу:

drop table if exists query;
create table query (
	   searchid serial primary key,   -- уникальный идентификатор поискового запроса
	   year int,
	   month int,
	   day int,
	   userid int,   -- уникальный id пользователя
	   ts bigint,   -- время запроса в формате unix timestamp
	   devicetype varchar(50),   -- тип устройства, с которого выполняется запрос
	   deviceid varchar(50),   -- уникальный id устройства
	   query varchar(50)   -- фраза под запрос
);

-- Наполнение таблицы:

insert into query (year, month, day, userid, ts, devicetype, deviceid, query)
values

(2024, 11, 20, 1, 1732086000, 'android', 'device_1', 'п'),
(2024, 11, 20, 1, 1732086005, 'android', 'device_1', 'пор'),
(2024, 11, 20, 1, 1732086009, 'android', 'device_1', 'порта'),
(2024, 11, 20, 1, 1732086018, 'android', 'device_1', 'портативная'),
(2024, 11, 20, 1, 1732086088, 'android', 'device_1', 'портативная кол'),
(2024, 11, 20, 1, 1732086090, 'android', 'device_1', 'портативная колонка'),
(2024, 11, 20, 2, 1732110900, 'smart_tv', 'device_2', 'к'),
(2024, 11, 20, 2, 1732110939, 'smart_tv', 'device_2', 'ковбой'),
(2024, 11, 20, 2, 1732110943, 'smart_tv', 'device_2', 'ковбойская'),
(2024, 11, 20, 2, 1732111011, 'smart_tv', 'device_2', 'ковбойская ш'),
(2024, 11, 20, 2, 1732111019, 'smart_tv', 'device_2', 'ковбойская шля'),
(2024, 11, 20, 2, 1732111020, 'smart_tv', 'device_2', 'ковбойская шляпа'),
(2024, 11, 20, 1, 1732116600, 'android', 'device_1', 'м'),
(2024, 11, 20, 1, 1732116602, 'android', 'device_1', 'май'),
(2024, 11, 20, 1, 1732116605, 'android', 'device_1', 'майка'),
(2024, 11, 20, 1, 1732116607, 'android', 'device_1', 'майка с'),
(2024, 11, 20, 1, 1732116678, 'android', 'device_1', 'майка с ег'),
(2024, 11, 20, 1, 1732116681, 'android', 'device_1', 'майка с егором'),
(2024, 11, 20, 1, 1732116692, 'android', 'device_1', 'майка с егором кри'),
(2024, 11, 20, 1, 1732117200, 'android', 'device_1', 'пиво светлое'),
(2024, 11, 20, 1, 1732117528, 'android', 'device_1', 'майка с егором кридом'),
(2024, 11, 20, 3, 1732128000, 'android', 'device_3', 'б'),
(2024, 11, 20, 3, 1732128002, 'android', 'device_3', 'бот'),
(2024, 11, 20, 3, 1732128005, 'android', 'device_3', 'ботин'),
(2024, 11, 20, 3, 1732128006, 'android', 'device_3', 'ботинки'),
(2024, 11, 21, 3, 1732128056, 'android', 'device_3', 'ботинки кр'),
(2024, 11, 21, 3, 1732128059, 'android', 'device_3', 'ботинки крутые'),
(2024, 11, 21, 3, 1732128098, 'android', 'device_3', 'ботинки крутые с'),
(2024, 11, 21, 3, 1732128101, 'android', 'device_3', 'ботинки крутые с шип'),
(2024, 11, 21, 3, 1732128103, 'android', 'device_3', 'ботинки крутые с шипами');

--select * from query

/*
 * Перейдем к определению is_final. Для написания запроса воспользуемся оконной функцией lead() - она возвращает
 * значение строки, положение которой задается смещением от текущей строки к концу раздела. 
 */

/*
 * По 'determ_is_final' (в запросе ниже): условия на is_final сформулированы недостаточно строго. Например, если условия на значения 
 * is_final "дословно" писать из условия задачи по порядку их изложения, то значение 2 присвоится ТОЛЬКО в том случае, если:
 *    
 * 	  1) условия, естесственнно, выполняются
 * 	  2) если до след. запроса прошло больше минуты, НО менее 3-х минут, поскольку условие б) априори выполнится и присвоится 1.
 * 
 * Т.е., одно условие включает в себя другое, если разница между запросами более 3-х минут.
 * Варианты решения данной проблемы:
 * 
 * 	  1) не считать это проблемой и полагаться полностью на предложенное условие задачи;
 * 	  2) условие на "= 2" (в) поставить выше условия б) (считать более "приоритетным");
 * 	  3) в любое из условий добавить отрицание другого
 * 
 * Давайте в данной задаче выберем 2-й вариант решения, чтобы не каверкать условие задачи, поскольку уточнений и требуемых ограничений
 * в условии нет.
 */

with for_lead as (   -- прописываем оконые функции
	 select *,
	 	    lead(ts) over w as next_ts,   -- время следующего запроса
	 	    lead(query) over w as next_query   -- следующий запрос
	 from query
	 window w as (partition by userid, deviceid order by ts)   -- партиция по юзеру и устройству (условие - с определеного устройства)
),
determ_is_final as (   -- определение is_final
	 select *,
	 	    case when next_ts is null then 1   -- а) вбил запрос и больше ничего не искал
	 	    	 when length(query) > length(next_query)
	 	    	 	  and next_ts - ts > 60 then 2   -- в) вбил запрос, след. запрос - не менее чем через минуту и короче предыдущего
	 	    	 when next_ts - ts > 180 then 1   -- б) вбил запрос, след. запрос - не менее чем через 3 минуты
	 	    	 else 0   --г) иначе 0
	 	    end as is_final
	 from for_lead
)
select year, month, day, userid, ts, devicetype, deviceid, query, next_query, is_final
from determ_is_final
where day = 20   -- выбираем 20 ноября (месяцы и года в таблице не отличаются)
	  and devicetype = 'android'
	  and is_final in (1, 2)
order by ts;










